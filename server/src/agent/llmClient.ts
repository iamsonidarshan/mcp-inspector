/**
 * Unified LLM Client Interface
 * Supports multiple LLM providers: Claude, Gemini
 */

export interface ToolInfo {
  name: string;
  description?: string;
  inputSchema: {
    type: string;
    properties?: Record<
      string,
      {
        type: string;
        description?: string;
        enum?: string[];
      }
    >;
    required?: string[];
  };
}

export interface ParameterSource {
  paramName: string;
  sourceTool: string;
  sourceField: string;
  confidence: number;
}

export interface DependencyAnalysis {
  tool: string;
  requiredParams: string[];
  canExecuteWithoutContext: boolean;
  suggestedOrder: number;
  dependencies: ParameterSource[];
}

export interface ExtractedParams {
  params: Record<string, unknown>;
  sources: Record<string, string>;
  confidence: number;
  missingParams: string[];
}

export type LLMProvider = "claude" | "gemini" | "openai";

export interface LLMClientConfig {
  provider: LLMProvider;
  apiKey: string;
}

/**
 * Abstract LLM Client Interface
 */
export interface ILLMClient {
  readonly provider: LLMProvider;

  analyzeToolDependencies(tools: ToolInfo[]): Promise<DependencyAnalysis[]>;

  extractParameters(
    targetTool: ToolInfo,
    availableContext: Record<string, unknown>,
  ): Promise<ExtractedParams>;

  selectNextTool(
    availableTools: ToolInfo[],
    executedTools: string[],
    availableContext: Record<string, unknown>,
    currentDepth: number,
    maxDepth: number,
  ): Promise<{ tool: string | null; reason: string }>;
}

/**
 * Shared prompts for both providers
 */
export const PROMPTS = {
  analyzeToolDependencies: (
    toolDescriptions: unknown,
  ) => `You are analyzing MCP (Model Context Protocol) tools for an autonomous agent.

Given these tools, analyze which tools can be called first (no dependencies) and which tools require outputs from other tools.

Tools:
${JSON.stringify(toolDescriptions, null, 2)}

For each tool, determine:
1. Which parameters are required
2. Whether it can be executed without any prior context (e.g., list_resources, get_inventory)
3. Which other tools might provide values for its parameters
4. Suggested execution order (1 = first, higher = later)

Respond with ONLY a JSON array, no markdown, no explanation:
[
  {
     "tool": "toolName",
     "requiredParams": ["param1", "param2"],
     "canExecuteWithoutContext": true/false,
     "suggestedOrder": 1,
     "dependencies": [
       {
         "paramName": "resourceId",
         "sourceTool": "list_resources",
         "sourceField": "id",
         "confidence": 0.9
       }
     ]
  }
]`,

  extractParameters: (
    targetTool: ToolInfo,
    availableContext: Record<string, unknown>,
  ) => `You are helping an autonomous agent call MCP tools.

Target tool to call:
${JSON.stringify(
  {
    name: targetTool.name,
    description: targetTool.description,
    parameters: targetTool.inputSchema?.properties || {},
    required: targetTool.inputSchema?.required || [],
  },
  null,
  2,
)}

Available context from previous tool calls:
${JSON.stringify(availableContext, null, 2)}

Extract the parameter values needed for "${targetTool.name}" from the context.
Match parameter names intelligently (e.g., "cloudId" in context matches "cloudId" parameter).
GENERATE SYNTHETIC DATA: If a tool requires parameters (like "title", "description", "comment", "body") and you DO NOT have a specific value from context, YOU MUST GENERATE A PLAUSIBLE VALUE.
   - Do not request user input for these.
   - Example: title="Automated Issue", description="Generated by agent", comment="Test comment".
   - This ONLY applies to free-text fields, not IDs or enumeration values.
Respond with ONLY a JSON object, no markdown:
{
  "params": { "paramName": "extractedValue" },
  "sources": { "paramName": "toolName.fieldPath" },
  "confidence": 0.0-1.0,
  "missingParams": ["paramsThatCouldNotBeFound"]
}`,

  selectNextTool: (
    executedTools: string[],
    availableContext: Record<string, unknown>,
    unexecutedTools: ToolInfo[],
    currentDepth: number,
    maxDepth: number,
  ) => `You are an autonomous agent selecting which MCP tool to call next.

ALREADY EXECUTED - DO NOT SELECT THESE AGAIN:
${JSON.stringify(executedTools)}

Available context from executed tools:
${JSON.stringify(availableContext, null, 2)}

AVAILABLE TOOLS (pick from these ONLY):
${JSON.stringify(
  unexecutedTools.map((t) => ({
    name: t.name,
    description: t.description,
    parameters: t.inputSchema?.properties || {},
    required: t.inputSchema?.required || [],
  })),
  null,
  2,
)}

Current depth: ${currentDepth}/${maxDepth}

STRATEGY FOR TOOL SELECTION:
1. NEVER select a tool from the "ALREADY EXECUTED" list. matching strictly by name.
2. CHECK FOR ERRORS: if a tool call returned 401 (Unauthorized) or 403 (Forbidden), YOU MUST NOT retry that tool. It will fail again.
3. UNDERSTAND PARAMETERS: Read the description of each parameter in the 'parameters' object. Understand the semantic meaning of each parameter to ensure you have the correct data.
4. Look for tools that can run with available parameters (id, name, path, etc.)
5. If you need more IDs (e.g. resource IDs, user IDs), use SEARCH/LIST/LOOKUP tools:
   - "search" tools can find items using keywords or queries
   - "list" or "get...s" (plural) tools return collections of items with their IDs
   - "lookup" tools can find specific items
6. Priority order:
   a. GET/READ tools (to discover resources and data). Prioritize these above all else.
   b. Within GET/READ tools:
      i. Tools with NO required params (root discovery)
      ii. SEARCH/LIST tools (discovery of IDs)
      iii. GET tools (fetching details)
   c. CREATE/UPDATE/DELETE tools (state modifiers). SKIP A TOOL if you don't have all required params and you are stuck in loop while determining the parameters.
7. If no tool can be executed with available params, return null

Example: If you need "repositoryId" but don't have it, call "list_repositories" or "search_repositories" first.

Respond with ONLY a JSON object:
{
  "tool": "toolName" or null if none can be executed,
  "reason": "Brief explanation"
}`,
};

/**
 * Parse JSON from LLM response, handling markdown code blocks
 */
export function parseJSONResponse<T>(response: string): T {
  // Remove markdown code blocks if present
  let cleaned = response.trim();
  if (cleaned.startsWith("```json")) {
    cleaned = cleaned.slice(7);
  } else if (cleaned.startsWith("```")) {
    cleaned = cleaned.slice(3);
  }
  if (cleaned.endsWith("```")) {
    cleaned = cleaned.slice(0, -3);
  }
  return JSON.parse(cleaned.trim());
}
